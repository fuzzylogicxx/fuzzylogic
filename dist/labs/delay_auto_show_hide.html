<!doctype html>
<html lang="en-GB">
<head>
    <meta charset="utf-8">
  <title>Scroll</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style type="text/css">

    @supports (transform: translateY(-10rem)) and (transition: .35s ease-in-out 1s) {

      @keyframes show {
        0% { transform: translateY(-10rem); }
        100% { transform: translateY(0); }
      }
      .alert {
        animation: show ease 5s;
      }
      .cuts-the-mustard .alert {
        animation: none;
        transform: translateY(-10rem);
        transition: .35s ease-in-out 1.5s;
      }
      .cuts-the-mustard .alert-visible {
        transform: translateY(0);
      }
      .cuts-the-mustard .alert-dismissed {
        transform: translateY(-10rem);
        transition: .4s ease-in-out 0;
      }

    }

    /* Notes:
    The requirement for a delay ruled out CSS-only solutions.
    We can delay keyframe animations with CSS animation-delay, but that’d make the element visible rather than hidden at the start. */

    /* Progressive Enhancement Strategy:
    1: Only hide the alert if we have CSS3 support for showing it.
    2: For initial hiding use a CSS3 keyframe animation.
    3: Make this baseline CSS3 animation slow, to allow time for JS to intercept before the alert shows.
    3: If JS is available, use it to enhance the experience by adding classes for delay + hide.
    */





    /* non-important styles */

    .alert {
      border: 4px solid #333;
      padding: 1rem;
      margin: 2rem 1rem;
      text-align: center;
    }

    body {
      font-family: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      font-size: 125%;
      margin: 0 auto;
      max-width: 42em;
      width: 88%;
    }

    input,
    textarea,
    select,
    button {
      font: inherit;
    }

  </style>
</head>
<body>
  <!-- <h1>Auto slide-in (after delay) then slide out w. CSS and vanilla JS</h1> -->

  <div class="alert">
    <p>Heads up! There’s a new message for you. I will self-destruct.</p>
  </div>

  <script type="text/javascript">

    // Get our alert element
    var alert = document.querySelector('.alert');

    window.addEventListener('load', function (event) {
      // If this part is running then the browsing experience "cuts the mustard" so apply a CSS class to that effect.
      document.documentElement.classList.add('cuts-the-mustard');
    }, false);

    // Add a class which will animate the alert into view.
    // Note: it doesn’t work if we apply this at the same time as applying the ".cuts-the-mustard" class i.e. in the above onload event listener. They’d cancel each other out. It needs a timing gap hence the setTimeout.
    window.setTimeout(function() {
      alert.classList.add('alert-visible');
    }, 100);

    // After a few seconds add a class on the element to have CSS remove it.
    window.setTimeout(function() {
        alert.classList.add('alert-dismissed');
    }, 5000);

  </script>

</body>
</html>
